## ChromaDB

ChromaDB is an open-source vector database designed for storing, searching, and managing high-dimensional embeddings from text, images, and other data types. It is widely used in AI for semantic search, retrieval, and recommendation systems.

- **Embeddings:** Numeric vectors representing data, generated by external models.
- **Collections:** Logical groups of documents and their embeddings, similar to tables in relational databases.
- **Documents:** Data items (typically text) stored with their embeddings and optional metadata.

### Chroma Data Model

ChromaDB’s data model is built for simplicity, flexibility, and scalability. It introduces three core abstractions—**Tenants**, **Databases**, and **Collections**—to help you organize and manage data efficiently across different environments and use cases.

#### 1. Collections

A **collection** is the primary unit for storing and querying data in ChromaDB. Collections are independently indexed and optimized for fast retrieval using vector similarity, full-text search, and metadata filtering. In distributed setups, collections can be sharded or migrated across nodes, with ChromaDB handling memory management transparently.

Each collection contains multiple items, and each item includes:

- **ID**: Unique identifier
- **Embedding vector**: Numeric representation of the item
- **Metadata**: Optional key-value pairs
- **Document**: The original data (e.g., text)

```txt
ID: "article_001"
Embedding: [0.12, 0.98, ...]
Metadata: {"source": "Reuters", "date": "2024-08-01"}
Document: "AI is transforming the finance industry..."
```

#### 2. Databases

Collections are grouped into **databases**, which act as logical namespaces. Databases help organize collections by environment (e.g., "staging" vs. "production") or application.

- Each database contains multiple collections.
- Collection names must be unique within a database.

```txt
Databases example:
- `production_db`: Contains collections for live applications
- `staging_db`: Contains collections for testing

In `production_db`, you might have collections like `news_articles`, `user_profiles`, and `product_reviews`.
```

#### 3. Tenants

A **tenant** represents a user, team, or organization, providing complete data isolation. Tenants ensure that data and metadata are never shared between different users or groups. Access control, quotas, and billing are managed at the tenant level.

- Tenants isolate data for different users or organizations.
- Each tenant can have multiple databases and collections.

**Example:**  
On a SaaS platform, each customer is assigned a separate tenant:

- Tenant: `alice_team` (with its own databases and collections)
- Tenant: `bob_corp` (completely isolated data and access)

When Alice uploads documents, they are stored under her tenant and only accessible to her team. Bob’s data is stored separately and is never visible to Alice. All queries are scoped to the tenant for strict isolation.

**Filtering and Sorting:**  
Within a tenant’s collections, you can filter and sort using metadata (e.g., by user, date, category):

```python
# Create tenants, databases, and collections
chroma_db.create_tenant("alice_team")
chroma_db.create_database(tenant="alice_team", database="project_db")
chroma_db.create_collection(tenant="alice_team", database="project_db", collection="project_docs")

# Query with filtering and sorting
results = chroma_db.query(
    tenant="alice_team",
    collection="project_docs",
    filter={"category": "finance"},
    sort_by="date",
    top_k=10
)
```

This retrieves only Alice’s documents in the "finance" category, sorted by date, with complete isolation from other tenants.

## ChromaDB Clients

ChromaDB clients are libraries and tools for connecting to a ChromaDB instance, performing operations (like creating collections, adding/querying data), and managing databases. The client type determines how data is stored, accessed, and scaled.

### Client Types

#### 1. Ephemeral (In-Memory) Client

- **Stores data in RAM**; data is lost when the process exits.
- **Use case:** Fast prototyping, unit tests, temporary workflows.

```python
import chromadb
client = chromadb.Client()  # In-memory by default

collection = client.create_collection(name="demo_collection")
collection.add(
    documents=["Quick test document"],
    ids=["test1"],
    embeddings=[[0.1, 0.2, 0.3]]
)
```

#### 2. Persistent (On-Disk) Client

- **Stores data on disk** for durability across restarts.
- **Use case:** Production, long-running apps, persistent data.

```python
import chromadb
client = chromadb.PersistentClient(path="/data/chroma_db")

collection = client.get_or_create_collection(name="prod_collection")
collection.add(
    documents=["Persistent storage example"],
    ids=["prod1"],
    embeddings=[[0.4, 0.5, 0.6]]
)
```

#### 3. Client-Server Mode

- **ChromaDB runs as a server process**; clients connect remotely via HTTP/REST.
- **Use case:** Distributed teams, cloud deployments, remote access, scalability.

Start the server:

```bash
chroma run --path /data/chroma_db
```

Connect from Python:

```python
import chromadb
client = chromadb.HttpClient(host="localhost", port=8000)

collection = client.get_or_create_collection(name="remote_collection")
collection.add(
    documents=["Remote access example"],
    ids=["remote1"],
    embeddings=[[0.7, 0.8, 0.9]]
)
```

#### 4. REST API Access

- **Interact with ChromaDB server via HTTP requests** from any language.

```python
import requests

response = requests.post(
    "http://localhost:8000/collections",
    json={"name": "api_collection"}
)
print(response.json())
```

#### 5. Third-Party Integrations

- **Integrate ChromaDB with frameworks** like LangChain or LlamaIndex for AI pipelines.

```python
from langchain.vectorstores import Chroma

vectorstore = Chroma(
    collection_name="langchain_collection",
    embedding_function=my_embedding_function
)
```

### Typical Scenarios

- **Local prototyping:** Use ephemeral client for quick tests.
- **Production:** Use persistent or server mode for reliability.
- **Distributed teams:** Use client-server mode for remote access.
- **Multi-language:** Use REST API for integration with non-Python apps.
- **AI/ML pipelines:** Integrate with LangChain, LlamaIndex, etc.

### Best Practices

- Use ephemeral mode for experiments; persistent or server mode for real projects.
- Secure server deployments (authentication, access control).
- Monitor client connections and usage for reliability.
- Choose the client type that matches your workflow and scalability needs.

### Essential ChromaDB Operations

#### 1. Initialize the Client

The client is your main interface to ChromaDB, handling connections and database operations.

```python
import chromadb
client = chromadb.Client()
```

#### 2. Create or Access Collections

Collections organize documents and embeddings by topic, project, or use case.

```python
# Create a new collection
collection = client.create_collection(name="my_collection")

# Get or create a collection
collection = client.get_or_create_collection(name="my_collection")
```

#### 3. Add Documents and Embeddings

Generate embeddings externally before adding.

- `documents`: List of texts or data items.
- `ids`: Unique identifiers for each document.
- `embeddings`: List of vectors (same length as documents).
- Optional metadata can be included.

```python
collection.add(
    documents=["AI is transforming industries", "Python is a versatile language"],
    ids=["doc1", "doc2"],
    embeddings=[[0.1, 0.2, 0.3], [0.9, 0.8, 0.7]]
)
```

#### 4. Query for Similar Documents

Find documents most similar to a query embedding.

```python
results = collection.query(
    query_embeddings=[[0.1, 0.2, 0.3]],
    n_results=2
)
```

#### 5. Retrieve Documents by ID

Fetch specific documents and their embeddings.

```python
docs = collection.get(ids=["doc1"])
```

#### 6. Update Documents and Embeddings

Modify existing documents and embeddings. IDs must exist.

```python
collection.update(
    ids=["doc1"],
    documents=["Updated document text"],
    embeddings=[[0.2, 0.3, 0.4]]
)
```

#### 7. Delete Documents

Remove documents and their embeddings.

```python
collection.delete(ids=["doc1"])
```

#### Convenience Methods

Count records:

```python
collection.count()
```

Peek at first 10 records:

```python
collection.peek()
```

### Generating Embeddings (External Step)

ChromaDB does **not** generate embeddings. Use external models to convert data to vectors before adding.

**Example: HuggingFace Sentence Transformers**

```python
from sentence_transformers import SentenceTransformer
model = SentenceTransformer('all-MiniLM-L6-v2')
embeddings = model.encode([
    "AI is transforming industries",
    "Python is a versatile language"
])
```

**Other options:**

- OpenAI embeddings (API)
- Ollama (`nomic-embed-text`)
